---
title: 【滑动窗口】找到字符串中所有字母异位词
date: 2025-08-22
---

## 题目：

题目链接：[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

题目描述：

> 给定两个字符串`s`和`p`，找到`s`中所有`p`的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
> 字母异位词：字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。

## 思路：

1. 判断边界条件：如果p.length > s.length，则没有子串可以异位，直接返回空数组。
2. 遍历p中的n个字符，用一个vector记录p中每个字符出现的次数，同时记录s中前n个字符出现的次数。
3. 如果s的前n个字符出现的次数和p的n个字符出现的次数相同，则将0加入结果数组。
4. 开始滑动窗口：
   1. 从s的第n个字符开始，窗口每次向右移动一个字符。
   2. 移除序列的第一个字符，并将该字符的出现次数减1。
   3. 加入序列的最后一个字符，并将该字符的出现次数加1。
   4. 如果窗口内的n个字符出现的次数和p的n个字符出现的次数相同，则将当前窗口的起始索引加入结果数组。
5. 返回结果数组。

## 代码：

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        /*
        核心逻辑错误：
            异位词要求字符种类和数量完全一致（仅顺序不同），但代码用unordered_map<char, bool>仅记录字符是否存在，未考虑数量，且错误排斥p中存在重复字符的情况（实际异位词允许重复字符，如 "aab" 和 "aba"）。
        滑动窗口逻辑混乱：
            窗口大小未正确控制为p的长度
            遇到不匹配字符时的处理逻辑错误，未正确重置窗口状态
        边界条件缺失：
            未处理p长度大于s的情况，循环条件可能漏掉最后一个有效窗口。
        判断异位词的方式错误：
            仅通过bool值判断字符是否出现，未验证数量是否匹配。
        */
        // unordered_map<char, bool> unorderedMap;

        // for(int i=0; i<p.length(); ++i){
        //     if(unorderedMap.find(p[i]) == unorderedMap.end()){
        //         unorderedMap[p[i]] = false;
        //     }else{
        //         cout << "p中有多个相同的字母" << endl;
        //     }
        // }

        // int left=0, right=0;
        // vector<int> res;
        // while(left < s.length()-p.length()){
        //     if(right-left == p.length()){
        //         left = right;
        //         continue;
        //     }
        //     if(unorderedMap.find(p[right]) != unorderedMap.end()){
        //         unorderedMap[p[right]] = true;
        //         right++;
        //     }else{
        //         int flag=p.length();
        //         for(int i=0; i<p.size(); ++i){
        //             if(unorderedMap[p[i]] == true){
        //                 flag--;
        //             }
        //         }
        //         if(flag==0){
        //             res.push_back(left);
        //         }
        //         left = ++right;
        //     }
        // }

        // return res;

        vector<int> res;

        // 边界条件判断：p比s长，直接返回空
        if(p.length() > s.length())return res;

        // 统计p中字符频率
        vector<int> pFreq(26,0), sFreq(26,0);
        for(int i=0; i<p.length(); ++i){
            // 在 C++ 中，字符运算需要使用单引号的字符，而不是双引号的字符串。
            pFreq[p[i] - 'a']++;
            sFreq[s[i] - 'a']++;
        }

        // 如果从首位开始的序列即为p的字母异位词，则res加入0
        if(sFreq == pFreq)res.push_back(0);

        // 滑动窗口：每次向右滑动一个窗口
        for(int i=p.length(); i<s.length(); ++i){
            // 移除左侧字符
            // 在 C++ 中，字符运算需要使用单引号的字符，而不是双引号的字符串。
            sFreq[s[i-p.length()] - 'a']--;

            // 加入右侧字符
            // 在 C++ 中，字符运算需要使用单引号的字符，而不是双引号的字符串。
            sFreq[s[i] - 'a']++;

            // 判断该序列是否为字母异位词
            if(sFreq == pFreq)res.push_back(i-p.length()+1);
        }

        return res;
    }
};
```