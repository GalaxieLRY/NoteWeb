---
title: 【双指针】移动零
date: 2025-08-21
---


## 题目：

题目链接：[移动零](https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

题目描述：

> 给定一个数组`nums`，编写一个函数将所有`0`移动到数组的末尾，同时保持非零元素的相对顺序。
> 请注意 ，必须在不复制数组的情况下原地对数组进行操作。

## 思路：

将所有非0数前提，后面的数全部置0：

1. 定义`noZero`，表示非0数的个数；
2. 遍历数组，遇到非0数，将其赋值给`nums[noZero]`，并将`noZero`加1；
3. 遍历结束后，将`nums[noZero...n-1]`全部置0。

双指针：

1. 定义`left`指向已处理好的序列的头部，`right`指向未处理的序列的尾部；
2. 遍历数组`right`从`0`到`n-1`，遇到非0数，交换`nums[left]`和`nums[right]`，并将`left`加1；

## 代码：

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // // 超时，存在效率问题
        // for(int i=0; i<nums.size(); ++i){
        //     if(nums[i]==0){
        //         for(int j=i; j<nums.size()-1; ++j){
        //             swap(nums[j], nums[j+1]);
        //         }
        //         // 处理连续0的情况
        //         --i;
        //     }
        // }

        /*******************************************************/

        // // 记录非0元素数量
        // int noZero=0;

        // // 将所有非0元素放到前面
        // for(int i=0; i<nums.size(); ++i){
        //     if(nums[i]!=0){
        //         nums[noZero++] = nums[i];
        //     }
        // }

        // // 将后面的元素全部置0
        // for(int i=noZero; i<nums.size(); ++i){
        //     nums[i]=0;
        // }

        /*******************************************************/

        // 双指针
        int left=0, right=0;
        while(right<nums.size()){
            if(nums[right]!=0){
                swap(nums[right], nums[left]);
                left++;
            }
            right++;
        }
    }
};
```