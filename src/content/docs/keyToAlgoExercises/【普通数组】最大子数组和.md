---
title: 【普通数组】最大子数组和
date: 2025-08-26
---


## 题目：

题目链接：[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

题目描述：

> 给你一个整数数组`nums`，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
> 子数组是数组中的一个连续部分。
> 子数组是数组中连续的非空元素序列。

## 思路：

遍历数组时，始终保持当前元素的最大和。如果遇到负数，则重新计算最大和。

## 代码：

```c++
class Solution {
public:

    // 时间复杂度太高：O(n3)，易超时

    // int getSum(vector<int>& nums, int left, int right){
    //     int res=0;
    //     while(left<=right){
    //         res+=nums[left];
    //         ++left;
    //     }
    //     return res;
    // }

    // int maxSubArray(vector<int>& nums) {
    //     int max_res=nums[0];
    //     int left=0, right=0;
    //     while(left<nums.size()){
    //         right=left;
    //         while(right<nums.size()){
    //             max_res = max(max_res, getSum(nums, left, right));
    //             ++right;
    //         }
    //         ++left;
    //     }
    //     return max_res;
    // }


    // Kadane 算法，时间复杂度为O(n)
    // 在遍历数组时，始终保持当前子数组的最大和，如果当前子数组的和为负数，则重新开始计算新的子数组。

    int maxSubArray(vector<int>& nums) {
        int max_sum=nums[0];
        int current_sum=nums[0];

        for(int i=1; i<nums.size(); ++i){
            // 要么将当前元素加入到子数组中，要么重新开始计算
            current_sum = max(nums[i], current_sum+nums[i]);

            max_sum = max(max_sum, current_sum);
        }

        return max_sum;
    }
};
```