---
title: 第6章 树和二叉树
date: 2025-08-15
---

## 6.1树的定义和基本术语

#### 树的特点：

非线性结构

1. 每一结点可以有零个或多个后继结点，但有且只有一个前驱结点（根结点除外)。
2. 数据结点按分支关系组织起来，清晰地反映了数据元素之间的层次关系。

树（Tree）是n（n≥0）个结点的有限集合，它或为空树（n = 0）；或为非空树，对于**非空树T**：

1. 有且仅有一个称之为根的结点；
2. 除根结点以外的其余结点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm, 其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

#### 树的表示：

树形表示法、括号表示法（前两种最常用）、嵌套集合表示法、凹入表示法

#### 基本术语：

树的高度：即树的层数

![树的高度](.\图片\树的高度.jpg)

1、**结点的度与树的度**：树中一个结点的子树的个数称为该结点的度。树中各结点的度的最大值称为树的度，通常将度为m 的树称为m次树或者m叉树。    

2、**分支结点与叶结点**：度不为零的结点称为非终端结点，又叫分支结点。度为零的结点称为终端结点或叶结点（或叶子结点）。

度为1的结点称为单分支结点；度为2的结点称为双分支结点，依此类推。

3、**路径与路径长度**：两个结点di和dj的结点序列（di，di1，di2，…，dj）称为路径。其中<dx，dy>是分支。

   路径长度等于路径所通过的结点数目减1（即路径上分支数目）。

4、**孩子结点、双亲结点和兄弟结点**：在一棵树中，每个结点的后继，被称作该结点的孩子结点（或子女结点）。相应地，该结点被称作孩子结点的双亲结点（或父母结点）。具有同一双亲的孩子结点互为兄弟结点。而双亲不同但双亲在同一层的孩子结点互为堂兄弟。

5、**子孙结点和祖先结点**：以某结点为根的子树中的任一结点都成为该结点的子孙。结点的祖先是从根到该结点所经分支上的所有结点。

6、**结点的层次和树的高度**：树中的每个结点都处在一个层次上。结点的层次从树根开始定义，根结点为第1层，它的孩子结点为第2层，以此类推，一个结点所在的层次为其双亲结点所在的层次加1。

   树中结点的最大层次称为树的高度（或树的深度）。

7、**有序树和无序树**：若树中各结点的子树是按照一定的次序从左向右安排的，且相对次序是不能随意变换的，则称为有序树，否则称为无序树。

8、**森林**：零棵或多棵互不相交的树的集合称为森林。

#### 性质

1. 树中的结点数等于所有结点的度数加1（度之和==分支数=n-1;所以n=度之和+1；）
2. ![树的性质2](.\图片\树的性质2.jpg)
3. ![树的性质3](.\图片\树的性质3.jpg)

#### 基本运算

**树的遍历**

先根遍历、后根遍历、层次遍历（前提条件：树不空）

抽象数据类型描述：

```cpp
ADT Tree
{  数据对象：
         D={ai | 1≤i≤n,n≥0,ai为ElemType类型}
   数据关系：
         R={<ai,aj>| ai,aj∈D,1≤i,j≤n,其中有且仅有一个结点没有前驱结点，其余每个结点只有一个前驱结点，但可以有零个或多个后继结点}
   基本运算：
 InitTree(&t)：初始化树，造一棵空树t。
 DestroyTree(&t)：销毁树，释放树t占用的内存空间。
 TreeHeight(t)：求树t中的高度。
 Parent(t,p)：求树t中p所指结点的双亲结点。
  Brother(t,p)：求树t中p所指结点的所有兄弟结点。
  Sons(t,p):求树t中p所指结点的所有子孙结点。
……
}
```

#### 存储结构

**双亲数组存储结构**

适用于双亲的操作，但不适用于孩子的操作

```cpp
typedef struct 
{ ElemType data;   //结点的值
　int parent;      //指向双亲位置
}PTree[MaxSize];
```

如：

![双亲数组存储示例](.\图片\双亲数组存储示例.jpg)

**孩子链表存储结构**

便于实现孩子的操作，但不适用于双亲的操作

把每个结点的孩子结点排列起来，看成是一个线性表，且以单链表作存储结构，则 n个结点有 n 个孩子链表（叶子的孩子链表为空)。而 n 个头指针又组成一个线性表，为便于查找，采用顺序存储结构。

![孩子链表存储示例](.\图片\孩子链表存储示例.jpg)

```cpp
typedef struct CTNode {   //孩子结点
    int child;
  　struct CTNode *next; 
} *ChildPtr;

typedef struct {　 //双亲结点结构
    ElemType data; 
    CTNode* firstchild; // 孩子链的头指针
} CTBox;

typedef struct {  //树结构:
    CTBox nodes[MAX_TREE_SIZE];
    int n, r; // 结点数和根结点的位置    
} CTree;
```

可根据某种需要，将二者结合起来，即带双亲的孩子链表。

**左孩子右兄弟链存储结构**

```cpp
typedef struct CSNode
{  ElemType          data;
   struct CSNode   *firstchild;
  struct CSNode  *nextsibling;
}CSNode,*CSTree;
```

![左孩子右兄弟链存储示例](.\图片\左孩子右兄弟链存储示例.jpg)



## 6.2二叉树

### 6.2.1二叉树的定义

二叉树是有限的结点集合，这个集合可以是空，可以是由一个根节点和两棵互不相交的称为左子树和右子树的二叉树组成。

#### 基本特点：

- 结点的度小于等于2
- 有序树（子树有序，不能颠倒）

![二叉树的五种不同形态](.\图片\二叉树的五种不同形态.jpg)

注：二叉树与度为2的树是不同的

- 度为2的树至少有3个结点，至少有一个结点的度为2，而二叉树的结点数可以为0
- 度为2的树不区分子树的次序，而二叉树中的每个节点最多有两个孩子结点，且必须区分左右子树

### 6.2.2二叉树的性质

1. 若在任意一棵二叉树中，有n0个叶子结点，有n2个度为2的结点，则：n0=n2+1
2. 二叉树的第i层上至多有2的i-1次方（i≥1）个结点。
3. 深度为h的二叉树中至多含有2的h次方-1个结点（h≥1）

#### 特殊形态的二叉树

**1. 满二叉树**

   - 所有分支结点都有双分结点
   - 并且叶节点都集中在二叉树的最下一层
   - 高度为h的满二叉树恰好有2的h次方-1个结点

**2. 完全二叉树**

   - 除最后一层外，每一层都取最大结点数，并且最下一层结点都集中在该层最左边的若干位置。
   - 完全二叉树实际上是对应的满二叉树删除叶结点层最右边若干个结点得到的。
   - 在一棵完全二叉树中最多只有下面两层的结点的度数小于2
   - ![完全二叉树示例](.\图片\完全二叉树示例.jpg)

   完全二叉树的性质：

   - n1=0或1，由n的奇偶决定。n为奇数，n1=0；n为偶数，n1=1
   - 若编号为i的结点有左孩子结点，则左孩子结点的编号为2i；若编号为i的节点有右孩子节点，则右孩子节点的编号为2i+1；
   - 除树根节点外，若一个结点的编号为i，则其双亲节点编号为i/2；
   - 若i<=n/2，则编号为i的结点为分支结点，否则为叶节点
   - 具有n个（n>0）结点的完全二叉树的高度为(log2 n)+1或log2 (n+1)

#### 二叉树抽象数据类型的描述

```cpp
ADT BTree
{
数据对象：
    D={ai | 0≤i≤n-1，n≥0}  //为了简单，除了特别说明外假设结点值为char
数据关系：
    R={r}
    r={<ai，aj> | ai，aj∈D， 0≤i，j≤n-1，当n=0时，称为空二叉树；否则其中有一个根结点，其他结点构成根结点的互不相交的左、右子树，该左、右两棵子树也是二叉树 }
基本运算：
（1）CreateBTNode(*b,*str)：根据二叉树括号表示法的字符串*str生成对应的链式存储结构。
（2）DestroyBT(*b)：销毁二叉链b并释放空间。
（3）FindNode(*b,x)：在二叉树b中寻找data域值为x的结点，并返回指向该结点的指针。
（4）LchildNode(p)和RchildNode(p)：分别求二叉树中结点*p的左孩子结点和右孩子结点。
（5）DispBTNode(*b)：以括号表示法输出一棵二叉树。    
（6）BTNodeDepth(*b)：求二叉树b的高度。若二叉树为空，则其高度为0；否则，其高度等于左子树与右子树中的最大高度加l。
}
```

### 6.2.3二叉树的存储结构

#### 二叉树的顺序存储结构

实现：按完全二叉树的节点层次编号，依次存放二叉树中的数据元素

![完全二叉树顺序存储](.\图片\完全二叉树顺序存储.jpg)

非完全二叉树转为完全二叉树，先用虚节点补全成为完全二叉树，然后再对结点编号

![非完全二叉树顺序存储](.\图片\非完全二叉树顺序存储.jpg)

优点：适合存储完全二叉树或满二叉树

缺点：如果需要增加很多空结点才能将一棵二叉树改造成为一棵完全二叉树，采用顺序存储结构会造成空间的大量浪费，这时不宜用顺序存储结构。

特点：

- 对于完全二叉树来说，其顺序存储是十分合适的。
- 对于一般的二叉树，特别是对于那些单分支结点较多的二叉树来说是很不合适的，因为可能只有少数存储单元被利用，特别是对退化的二叉树（即每个分支结点都是单分支的)，空间浪费更是惊人。
- 在顺序存储结构中，找一个结点的双亲和孩子都很容易。

#### 二叉树的链式存储结构——二叉链表

![二叉链表示意](.\图片\二叉链表示意.jpg)

特点：

- 占用的存储空间与树形没有关系，只与树中结点个数有关。

- 在二叉链中，找一个结点的孩子很容易，但找其双亲不方便。

一棵树采用左孩子右兄弟链存储结构表示->二叉链

**三叉链表：**

![三叉链表](.\图片\三叉链表.jpg)

**静态二叉链表：**

![静态二叉链表](.\图片\静态二叉链表.jpg)

## 6.3遍历二叉树和线索二叉树

### 6.3.1遍历二叉树

遍历：按照某种次序访问二叉树中的所有结点，使得每个结点被访问一次且仅被访问一次。

先序遍历

![先序遍历](.\图片\先序遍历.jpg)

中序遍历

![中序遍历](.\图片\中序遍历.jpg)

后序遍历

![后序遍历](.\图片\后序遍历.jpg)

**利用二叉树求解表达式的值**

若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息；

若表达式为“第一操作数 运算符 第二操作数”的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身又为表达式。

#### 二叉树遍历算法

存储结构为二叉链表

```cpp
   typedef struct node
 {      ElemType       data;
        struct node   *lchild；
        struct node   *rchild;
   } BTNode;
```

**递归算法**

1. 先序遍历的递归算法：

```cpp
void PreOrder(BTNode *b)
    { 
       if (b!=NULL)  //判空
       {       printf("%c ",b->data);    //访问根结点
	    PreOrder(b->lchild);
	    PreOrder(b->rchild);
       }
   }
```

上述访问是直接输出结点值。实际上，访问结点可以对该结点进行各种操作，如计数、删除结点等。

2. 中序遍历的递归算法：

```cpp
void InOrder(BTNode *b)
 {  
     if (b!=NULL)  //判空
    {        InOrder(b->lchild);
	 printf("%c ",b->data); //访问根结点
	 InOrder(b->rchild);
    } 
}
```

3. 后序遍历的递归算法：

```cpp
 void PostOrder(BTNode *b) 
 {  
     if (b!=NULL)  
    {   PostOrder(b->lchild);
        PostOrder(b->rchild);
        printf("%c ",b->data); //访问根结点
    } 
}
```

**利用栈将递归算法改为非递归算法：**
1. 先序

如先序非递归遍历算法步骤为：

（1）初始化一个空栈S，指针p指向根结点。

（2）当p非空或者栈S非空时，循环执行以下操作：

•如果p非空，访问p并将p进栈，接着将p指向该结点的左孩子；

•如果p为空，则弹出栈顶元素，将p指向该栈顶元素的右孩子。    

```cpp
 p＝b;
     while (栈不空 || p!=NULL)
    {     if(p!=NULL)
　      {    访问p所指结点;
              将p进栈;  p=p->lchild;
          }
         else
　      {     出栈p；
　　　     p＝p->rchild;
         }
    }   
```

```cpp
void PreOrder2(BTNode *b)
{       BTNode *p;  SqStack *st;	//定义一个顺序栈指针st
         InitStack(st);		//初始化栈st
         p=b;
         while (!StackEmpty(st) || p!=NULL)
          {	 
                  if(p!=NULL)	 //访问根结点，根指针进栈，遍历左子树
	     {	printf("%c "，p->data);	//访问结点p
		Push(st，p);		//结点p进栈
		p=p->lchild;		//移动到左孩子
	     }
	      //以下考虑栈顶结点
	     else                          //根指针退栈，遍历右子树
	      {	Pop(st，p);	//出栈结点p
		p=p->rchild;	//转向处理其右子树
	      }
           }
          DestroyStack(st);  //销毁栈
}

```

2. 中序

（1）初始化一个空栈S，指针p指向根结点。

（2）当p非空或者栈S非空时，循环执行以下操作：

•如果p非空，则将p进栈，接着将p指向该结点的左孩子；

如果p为空，则弹出栈顶元素并访问，将p指向该栈顶元素的右孩子。

```cpp
  p＝b;
     while (栈不空 || p!=NULL)
    {     if(p!=NULL)
　      {    将p进栈;  
              p=p->lchild;
          }
         else
　      {     出栈p；
               访问p所指结点;
　　　     p＝p->rchild;
         }
    }   
```

```cpp
void InOrder2(BTNode *b)
{       BTNode *p;  SqStack *st;	//定义一个顺序栈指针st
         InitStack(st);		//初始化栈st
         p=b;
         while (!StackEmpty(st) || p!=NULL)
          {	 
                  if(p!=NULL)	 //根指针进栈，遍历左子树
	     {	Push(st，p);		//结点p进栈
		p=p->lchild;		//移动到左孩子
	     }
	      //以下考虑栈顶结点
	     else                          //根指针退栈，访问根结点，遍历右子树
	      {	Pop(st，p);	//出栈结点p
		printf("%c "，p->data);	//访问结点p
                         p=p->rchild;	//转向处理其右子树
	      }
           }
          DestroyStack(st);  //销毁栈
}
```

3. 后序

可以使用一个pre前置结点记录上一次被访问的结点，如果当前结点p的右孩子是pre或者当前结点右孩子为NULL，那么就访问p

```cpp
//非递归后序遍历
void PostOrder(BiTree T){
    if(T!=NULL){
        BiTree St[105];
        int top=-1;
        BiTree p=T;
        BiTree r=NULL;
        while(p!=NULL||top!=-1){
            if(p!=NULL){
                St[++top]=p;
                p=p->lchild;
            }
            else{
                p=St[top];
                if(p->rchild!=NULL&&p->rchild!=r){
                    p=p->rchild;
                }else{
                    p=St[top--];
                    cout<<p->data<<' ';
                    r=p;
                    p=NULL;
                }
            }
        }
    }
}
```

​    从上述过程可知，栈中保存的是当前结点p的所有祖先结点（均未访问过）。 

​    例如，求一个结点的所有祖先结点等。

#### 层次遍历

对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每一个结点仅仅访问一次。

算法设计思路：

>使用队列
>
>I.将根结点进队；
>
>II.队不空时循环：从队列中出列一个结点*p，访问它；
>
>    若它有左孩子结点，将左孩子结点进队；
>
>    若它有右孩子结点，将右孩子结点进队。

```cpp
typedef struct 
{      BTNode*  data[MaxSize];	//存放队中元素
       int front，rear;		//队头和队尾指针
} SqQueue;			//环形队列类型
```

```cpp
void LevelOrder(BTNode *b)
{      BTNode *p;
        SqQueue *qu;			//定义环形队列指针
        InitQueue(qu);			//初始化队列
        enQueue(qu，b);			//根结点指针进入队列
        while (!QueueEmpty(qu))		//队不为空循环
        {	deQueue(qu，p);		//出队结点p
	printf("%c "，p->data);		//访问结点p
	if (p->lchild!=NULL)		//有左孩子时将其进队
	       enQueue(qu，p->lchild);
	if (p->rchild!=NULL)		//有右孩子时将其进队
	       enQueue(qu，p->rchild);
        } 
}
```

算法的时间复杂度为O(n)。

#### 二叉树的基本运算及其实现

归纳起来，二叉树有以下基本运算：

（1）**创建二叉树CreateBTNode(\*b,\*str)**：根据二叉树括号表示法的字符串*str生成对应的链式存储结构。

（2）**销毁二叉链存储结构DestroyBT(\*b)：**销毁二叉链b并释放空间。

（3）**查找结点FindNode(*b,x)**：在二叉树b中寻找data域值为x的结点，并返回指向该结点的指针。

（4）**找孩子结点LchildNode(p)和RchildNode(p)**：分别求二叉树中结点*p的左孩子结点和右孩子结点。

（5）**输出二叉树DispBTNode(\*b)**：以括号表示法输出一棵二叉树。 

（6）**求高度BTNodeDepth(\*b)**：求二叉树b的高度。若二叉树为空，则其高度为0；否则，其高度等于左子树与右子树中的最大高度加l。

**创建二叉链表**

**根据括号表示法字符串构造二叉树:**

算法设计

>先构造根结点N，再构造左子树L，最后构造右子树R
>
>构造右子树R时，找不到N了，所以需要保存N
>
>而括号（子树)是按最近原则匹配的，所以使用一个栈保存N

![创建二叉链表示例](.\图片\创建二叉链表示例.jpg)

```cpp
void CreateBTree(string str)	//创建以r为根结点的二叉链存储结构
{  stack<BTNode* > st;		//定义一个栈st
   BTNode* p;
   bool flag;
   int i=0;
   while (i<str.length())	//循环扫描str中每个字符
   {  switch(str[i])
      {
      case '(':
            st.push(p);		//刚刚新建的结点有孩子,将其进栈
            flag=true;
            break;
      case ')':
            st.pop();		//栈顶结点的子树处理完，出栈
            break;
      case ',':
            flag=false;		//开始处理栈顶结点的右孩子
            break;
       default:
           p=new BTNode(str[i]);	//新建一个结点p
           if (r==NULL)
              r=p;		//若尚未建立根结点,p作为根结点
           else				//已建立二叉树根结点
           {  if (flag && !st.empty())//新结点p作为栈顶结点的左孩子
                 st.top()->lchild=p;
              else if (!st.empty())	//新结点p作为栈顶结点的右孩子
                 st.top()->rchild=p;
           }
           break;
      }
      i++;				//继续遍历
   }
}
```

**根据扩展先序序列构造二叉树：**

扩展先序序列：将二叉树的每个结点都扩展成有两个孩子的结点，然后对扩展后的二叉树进行先序遍历得到的序列即为扩展先序序列。 

```cpp
void CreateBiTree(BTNode  *&b）
{
cin>>ch;
if (ch==‘#’)   b=NULL;  	//递归结束，建空树
else
{
    b=new BTNode;    b-＞data=ch; 	//生成根结点
    CreateBiTree(b-＞lchild);  //递归创建左子树
    CreateBiTree(b-＞rchild); //递归创建右子树
  }									
}										

```

**输出二叉链表**

(二叉树的二叉链 -> 二叉树的括号表示)    

```cpp
void DispBTNode(BTNode *b) 
{ if (b!=NULL)
 { printf("%c",b->data);
   if (b->lchild!=NULL || b->rchild!=NULL)
   { printf("(");
     DispBTNode(b->lchild); //递归处理左子树
     if (b->rchild!=NULL) printf(",");
     DispBTNode(b->rchild); //递归处理右子树
     printf(")");
   } 
  }
}
```

**查找结点**

采用先序遍历递归算法查找值为x的结点。找到后返回其指针，否则返回NULL。

递归模型如下

>f(b,x)=NULL                        若b=NULL
>
>f(b,x)=b                               若b->data==x
>
>f(b,x)=f(b->lchild,x)=p       若在左子树中找到了，即p=f(b->lchild,x)且p!=NULL
>
>f(b,x)=f(b->rchild,x)           其他情况 

```cpp
BTNode *FindNode(BTNode *b,ElemType x) 
{  
   BTNode *p;
   if (b= =NULL) return NULL;
   else if (b->data==x) return b;
   else
    {    
       p=FindNode(b->lchild,x);
	  if (p!=NULL) 
                    return p;
	  else 
                   return FindNode(b->rchild,x);
    }
}
```

**求高度**

设以b为根结点二叉树的高度为f(b)，空树高度为0，非空树高度为左、右子树中较大的高度加1。

递归模型如下：

>f(b)=0                                                          若b==NULL
>
>f(b)=MAX(f(b->lchild), f(b->rchild))+1      其他情况

```cpp
int Height()			//求二叉树高度的算法
{
   return Height1(r);
}
int Height1(BTNode* b)		//被Height函数调用
{  if (b==NULL)			//空树的高度为0
      return 0;
   else
      return max(Height(b->lchild),Height(b->rchild))+1;
}
```

**销毁二叉链**

递归模型如下：

>f(b)=不做任何事情                        若b==NULL
>
>f(b)=f(b->lchild); f(b->rchild); delete b;      其他情况

```cpp
void   DestroyBT(BTNode *&b)
{ 
      if (b==NULL) return ;
      else
      {     DestroyBT(b->lchild);
            DestroyBT(b->rchild);
            delete(b);  //剩下一个结点*b，直接释放
      }
}
```

程序验证

```cpp
//所有代码存放在BTree.cpp中

#include"BTree.cpp"	//引用二叉树类BTree 
int main()
{  string str="A(B(D(,G)),C(E,F))";
   char x='e';
   BTree bt;
   bt.CreateBTree(str);
   cout << "二叉树bt:"; bt.DispBTree(); cout << endl;
   cout << "bt的高度:" << bt.Height() << endl;
   if (bt.FindNode(x))
      cout << "bt中找到值为" << x << "的结点\n";
   else
      cout << "bt中没有找到值为" << x << "的结点\n";
   cout << "销毁二叉树\n";
   return 0;
}
```

总结：

- 二叉树的算法主要有基于递归遍历思路和直接采用递归算法设计思路两种。实际上，当求解问题较复杂时，直接采用递归算法设计方法更加简单方便。
- 一般地，二叉树由根、左右子树3部分构成，但可以看成两类，即根和子树。
  - 如果需要先处理根再处理子树，可以采用先序遍历思路
  - 如果需要先处理子树，再处理根，可以采用后序遍历思路

#### 二叉树的构造

定理：

若二叉树中各结点的值均不相同，则：由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树，但由先序序列和后序序列却不一定能唯一地确定一棵二叉树。 

先序+中序：

1. 由先序得到根；

2. 然后由中序分别得到左、右子树。

后序+中序：

1. 由后序得到根；

2. 由中序分别得到左、右子树。

### 6.3.2线索二叉树

术语：

>线索：指向结点前驱和后继的指针
>
>线索二叉树：加上线索的二叉树
>
>线索链表：加上线索的二叉链表
>
>线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程

- 若结点有左子树，则lchild指向其左孩子；否则， lchild指向其直接前驱(即线索)；
- 若结点有右子树，则rchild指向其右孩子；否则， rchild指向其直接后继(即线索) 。

![线索二叉树存储示例](.\图片\线索二叉树存储示例.jpg)

结点类型定义：

```cpp
  typedef struct BiThrNode 
  {      ElemType data;		//结点数据域
         int LTag，RTag;      		//增加的线索标记
         struct BiThrNode *lchild;		//左孩子或线索指针
         struct BiThrNode *rchild;		//右孩子或线索指针
  }  BiThrNode;		　　　	//线索树结点类型定义 
```

![先序线索二叉树](.\图片\先序线索二叉树.jpg)

![中序线索二叉树](.\图片\中序线索二叉树.jpg)

![后序线索二叉树](.\图片\后序线索二叉树.jpg)

## 6.4树和森林

1. 树转为二叉树

   ![树转为二叉树](.\图片\树转为二叉树.jpg)

2. 森林转为二叉树

   ![森林转为二叉树](.\图片\森林转为二叉树.jpg)

3. 二叉树还原为树

   ![二叉树还原为树](.\图片\二叉树还原为树.jpg)

4. 二叉树还原为森林

   ![二叉树还原为森林](.\图片\二叉树还原为森林.jpg)

## 6.5哈夫曼树及其应用

**术语**：

>路径：由一节点到另一节点间的分支所构成
>
>路径长度：路径上的分支数目
>
>哈夫曼树：带权路径长度最小的二叉树（也称最优二叉树）
>
>结点的带权路径长度：节点到根的路径长度与结点上权的乘积
>
>树的带权路径长度：树中所有叶子结点的带权路径长度之和

**哈夫曼树特征**：

- 权越大的叶子结点离根越近
- 权越小的叶子结点离根越远

**如何根据特征构造哈夫曼树**：贪心法，自底向上

**构造哈夫曼树原则**：

- 权值越大的叶结点越靠近根结点
- 权值越小的叶结点越远离根结点

**构造哈夫曼树的过程**：

   （1）给定的n个权值{W1，W2，…，Wn}构造n棵只有一个叶结点的二叉树，从而得到一个二叉树的集合F={T1，T2，…，Tn}。

   （2）在F中选取根结点的权值最小和次小的两棵二叉树作为左、右子树构造一棵新的二叉树，这棵新的二叉树根结点的权值为其左、右子树根结点权值之和。

   （3）在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中。

   （4）重复（2）、（3）两步，当F中只剩下一棵二叉树时，这棵二叉树便是所要建立的哈夫曼树。

**一棵有n个叶子结点的哈夫曼树共有多少个结点？**2n0-1个

因为n1=0,n0=n2+1，所以n=n0+n1+n2=2n0-1

### 应用

#### 判定树

在解决某些判定问题时，利用哈夫曼树可以得到最佳判定算法

如：编制一个将学生百分成绩按分数段分级的程序

![判定树示例](.\图片\判定树示例.jpg)



#### 哈夫曼编码

编码：将数据文件转换成由0、1组成的二进制串

哈夫曼编码：规定哈夫曼树中的左分支为0，右分支为1，则从根结点到每个叶结点所经过的分支对应的0和1组成的序列便为该结点对应字符的编码。（则哈夫曼编码属于0、1二进制编码）

特点：权值越大的字符编码越短，反之越长

实现：

存储结构——静态三叉链表

```cpp
#define  n  10
typedef struct {
	int weight;
	int parent,lchild,rchild;
} HTNode; 

HTNode  HT[2*n]; //数组存储哈夫曼树
//n个叶子构成的哈夫曼树的高度最高为n，码长最长为n-1
int HC[n+1][n]; /*存储编码表，每行存储一个字符的编码（第0行不使用），第一列HC[1][0]--HC[n][0]存放n个叶子结点的编码长度*/
```

步骤：

1. 初始化HT[1..2n-1]：lchild=rchild=parent=0
2. 初始化HT[1..2n-1]：lchild=rchild=parent=0
3. 进行以下n-1次合并，依次产生HT[i]，i=n+1..2n-1：
   - 在HT[1..i-1]中选两个未被选过(parent = 0)的weight最小的两个结点s1和s2 
   - 修改HT[s1]和HT[s2]的parent值： parent=i
   - 置HT[i]：weight=HT[s1].weight + HT[s2].weight ，lchild=s1, rchild=s2

构造哈夫曼树

```cpp
void CreatHuffmanTree ( )
{    int i,m=2*n-1;
     if(n<=1)       return;
     for( i=1;i<=m;++i)
     {       HT[i].lchild=0;      HT[i].rchild=0;           HT[i].parent=0;            }
     for( i=1;i<=n;++i)       cin>>HT[i].weight;   
     for( i=n+1;i<=m;++i)       //构造  Huffman树
     {       Select(i-1, s1, s2);   //在HT[1..i-1]中选择两个其双亲域为0,且权值最小的结点,并返回它们在HT中的序号s1和s2
            HT[s1].parent=i;   HT[s2] .parent=i;      //表示从F中删除s1,s2
            HT[i].lchild=s1;    HT[i].rchild=s2 ;     //s1,s2分别作为i的左右孩子
            HT[i].weight=HT[s1].weight + HT[s2].weight; //权值为左右孩子权值之和
     }
} 

void Select(int i,int &s1,int &s2)
{ //在HT[1..i]中选择两个其双亲域为0，且权值最小的结点，并返回它们在HT中的序号s1和s2
         int k,v1= INFINITY，v2 = INFINITY;//v1,v2分别记录最小值和次小值
         s1 = 0,s2 = 0;
         for(k=1; k<=i; k++)
         {       
             if(HT[k].parent == 0)
                if(HT[k].weight < v1)
                {      v2 = v1;   s2 = s1;   v1 = HT[k].weight;   s1 = k;	}
                else if( HT[k].weight < v2 )
                {      v2 = HT[k].weight;	s2 = k;		}
	
          }
}

```

构造哈夫曼编码

```cpp
void Huffman_Code()
{//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中
    int i, j,k,c,f;
    for( i=1; i <= n; i++) //逐个字符求哈夫曼编码
    {   k= 0;     //字符编码计数
        c=i;        f=HT[i].parent;
        while(f!=0)       //从叶子结点开始向上回溯，直到根结点
        {     k++;          //回溯一次k向后移动一个位置
             if(HT[f].lchild==c)   HC[i][k]=0; //结点c是f的左孩子，则生成编码0
             else        HC[i][k]=1;         //结点c是f的右孩子，则生成编码1
             c=f; f=HT[f].parent;        //继续向上回溯
        }      //求出第i个字符的编码 
        HC[i][0]=k;      //记录第i个字符的码长
     } 
     for (i=1;i<=n;i++)    //逆向输出 huffman编码表
     {      printf("%d:",ht[i].weight);
             for(j=HC[i][0];j>=1;j--)          printf("%d\n",HC[i][j]);
     }
}
```

哈夫曼编码结论

- 哈夫曼编码是不等长编码
- 哈夫曼编码是前缀编码，即任意字符的编码都不是另一字符编码的前缀
- 哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为2n-1
- 发送过程：根据由哈夫曼树得到的编码表送出字符数据
- 接收过程：按左0右1的规定，从根结点走到一个叶节点，完成一个字符的译码。反复此过程，直到接收数据结束