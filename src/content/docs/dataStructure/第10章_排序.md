---
title: 第10章 排序
date: 2025-08-15
---

内容摘自[Hello算法](https://www.hello-algo.com/chapter_sorting/)

## 选择排序

**工作原理**：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。

**算法流程**：

1. 初始状态下，所有元素未排序，索引区间为$[0,n-1]$；
2. 选取区间$[0,n-1]$中的最小元素，将其与索引0处的元素交换；
3. 选取区间$[1,n-1]$中的最小元素，将其与索引1处的元素交换；
4. 以此类推。经过$n-1$轮选择排序后，整个数组将变为有序。

**时间复杂度**：$O(n^2)$，非自适应排序

**空间复杂度**：$O(1)$，原地排序

**非稳定排序**：在交换元素时，如果两个元素相等，则不保证它们的相对顺序。

**代码示例**：

```c++
/* 选择排序 */
void selectionSort(vector<int> &nums) {
    int n = nums.size();
    // 外循环：未排序区间为 [i, n-1]
    for (int i = 0; i < n - 1; i++) {
        // 内循环：找到未排序区间内的最小元素
        int k = i;
        for (int j = i + 1; j < n; j++) {
            if (nums[j] < nums[k])
                k = j; // 记录最小元素的索引
        }
        // 将该最小元素与未排序区间的首个元素交换
        swap(nums[i], nums[k]);
    }
}
```

## 冒泡排序

**工作原理**：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 > 右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端。

**算法流程**：

1. 首先，对$n$个元素执行冒泡，将数组的最大元素交换至正确位置；
2. 然后，对$n-1$个元素执行冒泡，将数组的第二大元素交换至正确位置；
3. 以此类推，经过$n-1$轮冒泡后，前$n-1$大的元素都被交换至正确位置；
4. 仅剩的一个元素必是最小元素，无需排序，因此数组排序完成。

**时间复杂度**：$O(n^2)$，自适应排序

**空间复杂度**：$O(1)$，原地排序

**稳定排序**：由于在“冒泡”中遇到相等元素不交换。

**代码示例**：
```c++
/* 冒泡排序 */
void bubbleSort(vector<int> &nums) {
    // 外循环：未排序区间为 [0, i]
    for (int i = nums.size() - 1; i > 0; i--) {
        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
        for (int j = 0; j < i; j++) {
            if (nums[j] > nums[j + 1]) {
                // 交换 nums[j] 与 nums[j + 1]
                // 这里使用了 std::swap() 函数
                swap(nums[j], nums[j + 1]);
            }
        }
    }
}
```

## 插入排序

**工作原理**：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。

**算法流程**：

1. 初始状态下，数组的第1个元素已排序；
2. 选取数组的第2个元素作为`base`，将其插入到正确位置后，数组的前两个元素已排序；
3. 选取第3个元素作为`base` ，将其插入到正确位置后，数组的前 3 个元素已排序。
4. 以此类推，在最后一轮中，选取最后一个元素作为`base`，将其插入到正确位置后，所有元素均已排序。

**时间复杂度**：$O(n^2)$，自适应排序

**空间复杂度**：$O(1)$，原地排序

**稳定排序**：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。。

**代码示例**：

```c++
/* 插入排序 */
void insertionSort(vector<int> &nums) {
    // 外循环：已排序区间为 [0, i-1]
    for (int i = 1; i < nums.size(); i++) {
        int base = nums[i], j = i - 1;
        // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置
        while (j >= 0 && nums[j] > base) {
            nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位
            j--;
        }
        nums[j + 1] = base; // 将 base 赋值到正确位置
    }
}
```

## 快速排序

**工作原理**：

1. 选取数组最左端元素作为基准数，初始化两个指针`i`和`j`分别指向数组的两端。
2. 设置一个循环，在每轮中使用`i(j)`分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤2，直到`i`和`j`相遇时停止，最后将基准数交换至两个子数组的分界线。

**算法流程**：

1. 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。
2. 然后，对左子数组和右子数组分别递归执行“哨兵划分”。
3. 持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。

**时间复杂度**：$O(nlogn)$，非自适应排序

**空间复杂度**：$O(n)$，原地排序

**非稳定排序**：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。

**代码示例**：

```c++
/* 哨兵划分 */
int partition(vector<int> &nums, int left, int right) {
    // 以 nums[left] 为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j && nums[j] >= nums[left])
            j--;                // 从右向左找首个小于基准数的元素
        while (i < j && nums[i] <= nums[left])
            i++;                // 从左向右找首个大于基准数的元素
        swap(nums[i], nums[j]); // 交换这两个元素
    }
    swap(nums[i], nums[left]);  // 将基准数交换至两子数组的分界线
    return i;                   // 返回基准数的索引
}

/* 快速排序 */
void quickSort(vector<int> &nums, int left, int right) {
    // 子数组长度为 1 时终止递归
    if (left >= right)
        return;
    // 哨兵划分
    int pivot = partition(nums, left, right);
    // 递归左子数组、右子数组
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}
```

## 归并排序

**工作原理**：

1. 划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。
2. 合并阶段：当子数组长度为1时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。

**算法流程**：

1. 计算数组中点`mid`，递归划分左子数组`[left,mid]`和右子数组`[mid+1,right]`。
2. 递归执行步骤1，直至子数组长度为1时终止。

**时间复杂度**：$O(nlogn)$，非自适应排序

**空间复杂度**：$O(n)$，非原地排序

**稳定排序**：在合并过程中，相等元素的次序保持不变。

**代码示例**：

```c++
/* 合并左子数组和右子数组 */
void merge(vector<int> &nums, int left, int mid, int right) {
    // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]
    // 创建一个临时数组 tmp ，用于存放合并后的结果
    vector<int> tmp(right - left + 1);
    // 初始化左子数组和右子数组的起始索引
    int i = left, j = mid + 1, k = 0;
    // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j])
            tmp[k++] = nums[i++];
        else
            tmp[k++] = nums[j++];
    }
    // 将左子数组和右子数组的剩余元素复制到临时数组中
    while (i <= mid) {
        tmp[k++] = nums[i++];
    }
    while (j <= right) {
        tmp[k++] = nums[j++];
    }
    // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间
    for (k = 0; k < tmp.size(); k++) {
        nums[left + k] = tmp[k];
    }
}

/* 归并排序 */
void mergeSort(vector<int> &nums, int left, int right) {
    // 终止条件
    if (left >= right)
        return; // 当子数组长度为 1 时终止递归
    // 划分阶段
    int mid = left + (right - left) / 2;    // 计算中点
    mergeSort(nums, left, mid);      // 递归左子数组
    mergeSort(nums, mid + 1, right); // 递归右子数组
    // 合并阶段
    merge(nums, left, mid, right);
}
```

## 堆排序

**工作原理**：

1. 输入数组并建立小顶堆，此时最小元素位于堆顶。
2. 不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。

**算法流程**：

1. 输入数组并建立大顶堆。完成后，最大元素位于堆顶。
2. 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减1，已排序元素数量加1。
3. 从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。
4. 重复步骤2和步骤3，直至堆的长度为1。此时，整个数组排序完成。

**时间复杂度**：$O(nlogn)$，非自适应排序

**空间复杂度**：$O(1)$，原地排序

**非稳定排序**：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。

**代码示例**：

```c++
/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */
void siftDown(vector<int> &nums, int n, int i) {
    while (true) {
        // 判断节点 i, l, r 中值最大的节点，记为 ma
        int l = 2 * i + 1;
        int r = 2 * i + 2;
        int ma = i;
        if (l < n && nums[l] > nums[ma])
            ma = l;
        if (r < n && nums[r] > nums[ma])
            ma = r;
        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出
        if (ma == i) {
            break;
        }
        // 交换两节点
        swap(nums[i], nums[ma]);
        // 循环向下堆化
        i = ma;
    }
}

/* 堆排序 */
void heapSort(vector<int> &nums) {
    // 建堆操作：堆化除叶节点以外的其他所有节点
    for (int i = nums.size() / 2 - 1; i >= 0; --i) {
        siftDown(nums, nums.size(), i);
    }
    // 从堆中提取最大元素，循环 n-1 轮
    for (int i = nums.size() - 1; i > 0; --i) {
        // 交换根节点与最右叶节点（交换首元素与尾元素）
        swap(nums[0], nums[i]);
        // 以根节点为起点，从顶至底进行堆化
        siftDown(nums, i, 0);
    }
}
```