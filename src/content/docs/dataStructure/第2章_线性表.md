---
title: 第2章 线性表
date: 2025-08-15
---

# 线性表的类型定义

基本操作：

初始化，取值，查找，插入，删除

```c++
ADT LinearList
{
  数据： D = {a1, a2,…, an}
  关系： R = {<ai, ai+1> | i = 1, ..., n}
  操作：
    创建表       InitList(&L)：构造一个空的线性表L。
    销毁表       DestroyList(&L)：释放线性表L占用的内存空间。
    求表长       ListLength(L)：返回L中元素个数n。
    显示列表   DispList(L)：线性表L不为空时，顺序显示L中各结点的值域。
    取值     GetElem(L，i，&e)：用e返回L中第 i（1≤i≤n）个元素的值。     
    查找元素   locateElem(L，e)：返回L中第一个值域与e相等的逻辑位序。若这样的元素不存在，则返回值为0。
    插入元素   ListInsert(&L，i，e)：在L的第i（1≤i≤n）个元素之前插入新的元素e，L的长度增1。
    删除元素   ListDelete(&L，i，&e)：删除L的第i（1≤i≤n）个元素，并用e返回其值，L的长度减1。          
	…
}
```

# 线性表的顺序表示和实现

## 顺序表的类型定义

```c++
typedef int ElemType; //ElemType为元素的数据类型
#define  MAXSIZE 100 //线性表的最大长度    
typedef  struct 
{
 	 ElemType  *elem; //指向数据元素的基地址
  	 int  length; //线性表的当前长度            
 }SqList；
SqList L;
```

例子：

```c++
/*图书表的顺序存储结构类型定义*/
#define MAXSIZE 10000	   //图书表可能达到的最大长度 
typedef struct			//图书信息定义
{ 
   char no[20];			//图书ISBN
   char name[50];		//图书名字
   float price; 			//图书价格
}Book; 

typedef struct
{ 
   Book *elem;	             //存储空间的基地址 
   int   length;		//图书表中当前图书个数 
}SqList;		//图书表的顺序存储结构类型为SqList

```

## 顺序表的基本运算算法

### 初始化线性表L

```c++
bool InitList(SqList &L) //构造一个空的顺序表L
{ 
      L.elem=new ElemType[MAXSIZE];   //为顺序表分配空间
      if(!L.elem) 
           return false;//存储分配失败
      L.length=0;	            	  //空表长度为0
      return true;
}
```

### 销毁线性表L

```c++
void DestroyList(SqList &L)
{
    if (L.elem)    
        delete[]L.elem; //释放存储空间

}
```

### 清空线性表L

```c++
void ClearList(SqList  &L) 
{
     L.length=0;//将线性表的长度置为0
}
```

### 求线性表L的长度

```c++
int GetLength(SqList L)
{
      return (L.length);             
}
```

### 判断线性表L是否为空

```c++
bool IsEmpty(SqList L)
{
     return(L.length==0);
}
```

### 求某个数据元素值

该运算返回L中第 i（1≤i≤ListLength(L)）个元素的值，存放在e中。

本算法的时间复杂度为O(1)--> 体现了顺序表的随机存取特性

```c++
bool GetElem(SqList L，int i，ElemType &e)
{     
       if (i<1 || i>L.length) 
              return false; //判断i值是否合理，若不合理，返回false
       e=L.elem[i-1]; //第i-1的单元存储着第i个数据
       return true;
}  
```

### 按元素查找

该运算顺序查找第1个值域与e相等的元素的逻辑位序。若这样的元素不存在，则返回值为0。

```c++
int LocateElem(SqList L， ElemType e)
{     
      int i=0;
      while (i<L.length && L.elem[i]!=e)  
            i++;
      if (i>=L.length)  return 0;
      else  return  i+1;
}
```

### 插入运算

在顺序表L的第i个位置上插入新的元素e

算法步骤：

- 判断插入位置i 是否合法
- 判断顺序表的存储空间是否已满
- 将第n至第i 位的元素依次向后移动一个位置，空出第i个位置
- 将要插入的新元素e放入第i个位置
- 表长加1，插入成功返回true

插入算法的平均时间复杂度为O(n)

```c++
bool ListInsert_Sq(SqList  &L,int i ,ElemType e)
{
   if(i<1 || i>L.length+1) return false;	         //i值不合法
   if(L.length== MAXSIZE) return false;    //当前存储空间已满     
   for(j=L.length-1;j>=i-1;j--) 
         L.elem[j+1]=L.elem[j];    //插入位置及之后的元素后移
    L.elem[i-1]=e;                     //将新元素e放入第i个位置
    L.length++;		       //表长增1
    return true;
}
```

### 删除数据元素

算法步骤：

- 判断删除位置i 是否合法（合法值为1≤i≤n）
- 将欲删除的元素保留在e中
- 将第i+1至第n 位的元素依次向前移动一个位置
- 表长减1，删除成功返回OK

平均时间复杂度为O(n)

```c++
bool ListDelete_Sq(SqList &L,int I,ElemType &e)
{
    if( (i<1) || (i>L.length) ) return false;	 //i值不合法
    e = L.elem[i-1];
    for (j=i; j<=L.length-1; j++)                   
　  　L.elem[j-1]=L.elem[j];       //被删除元素之后的元素前移  
    L.length--;               	                 //表长减1
    return true;
}
```

## 顺序表优缺点

优点：

- 存储密度大（结点本身所占存储量/结点结构所占存储量）
- 可以随机存取表中任一元素

缺点：

- 在插入、删除某一元素时，需要移动大量元素
- 预先分配空间需按最大空间分配，利用不充分
- 属于静态存储形式，数据元素的个数不能自由扩充

# 线性表的链式表示和实现

## 单向链表

### 结点类型LNode定义：

```c++
typedef struct LNode     	   //定义单链表结点类型
{      ElemType data;
        struct LNode *next;     //指向后继结点
}  *LinkList; // *LinkList为LNode类型的指针，LNode* p<==>LinkList P
```

### 初始化线性表

```c++
void InitList(LinkList &L)
 {
        L=(LNode *)malloc(sizeof(LNode));    //创建头结点
        //L = new LNode;
        L->next=NULL;
 }
```

### 销毁线性表

逐一释放全部结点的空间

```c++
void DestroyList(LinkList &L)
{      LinkList p;
       while(L)
       {    p=L;  
            L=L->next;
            free(p);  //delete(p);
       }
}
```

### 判断线性表是否为空表

```c++
bool ListEmpty(LinkList L)
{
　　return(L->next==NULL);
}
```

### 求表长

```c++
int  ListLength(LinkList L)
{//返回L中数据元素个数
     LinkList p=L;  //p指向头结点
     int n=0;             
     while(p->next!=NULL)//遍历单链表,统计结点数
     {     n++;
           p=p->next;    
      } 
     return n; //循环结束，p指向尾结点，其序号n为结点个数
 }
```

### 输出线性表

逐一扫描单链表L的每个数据结点，并显示各结点的data域值。  

```c++
void DispList(LinkList  L)
{      LNode *p=L->next;	//p指向开始结点
       while (p!=NULL)		//p不为NULL，输出*p结点的data域
       {	cout<<p->data;
	        p=p->next;		//p移向下一个结点
       }
       cout<<endl;
}
```

### 求线性表L中位置i的数据元素

在单链表L中从头开始找到第i个结点，若存在第i个数据结点，则将其data域值赋给变量e。

算法步骤：

- 从第1个结点顺链扫描，用指针p指向当前扫描到的结点，p初值p = L->next
- j 做计数器，累计当前扫描过的结点数，j 初值为1
- 当p指向扫描到的下一结点时，计数器 j 加1
- 当 j = i 时，p所指的结点就是要找的第i个结点

```c++
int GetElem(LinkList L,int i,ElemType &e)
{ //获取线性表L中的第i个数据元素的值
     LinkList p=L->next;              //p指向第一个结点
     int j=1;         
     while(p != NULL && j<i )//向后扫描，直到p指向第i个元素或p为空 
     {       p=p->next;              j++;             } 
     if( p==NULL  || j>i )   
           return -1; //不存在第i个元素，或者i值不合法 
     else
     {     e=p->data; //取第i个元素 
           return 0; 
     }
} 
```

### 按元素查找位置

在单链表L中从头开始找第1个值域与e相等的结点，若存在这样的结点，则返回位置，否则返回0。

算法步骤：

- 从第一个结点起，依次和e相比较
- 如果找到一个其值与e相等的数据元素，则返回其在链表中的“位置”或地址
- 如果查遍整个链表都没有找到其值和e相等的元素，则返回0或“NULL”

1.返回位置序号

```c++
//在线性表L中查找值为e的数据元素
int LocateELem (LinkList L，Elemtype e) 
{ //返回L中值为e的数据元素的位置序号，查找失败返回0 
  LNode *p=L->next; int i=1;
  while(p!=NULL && p->data!=e)  
  {     p=p->next;     i++;    }          		
  if(p)     return i; //存在元素值为e的结点，返回其逻辑序号i
  else    return 0;//不存在元素值为e的结点，返回0
} 
```

2.返回地址

```c++
//在线性表L中查找值为e的数据元素
LNode * LocateELem (LinkList L，Elemtype e) 
{ //返回L中值为e的数据元素的地址，查找失败返回NULL
  LNode *p=L->next;
  while(p &&p->data!=e)  
        p=p->next;                		
  return p; 	
} 
```

### 插入数据元素

先在单链表L中找到第i-1个结点 *p，若存在这样的结点，将值为e的结点 *s插入到其后。

算法步骤：

- 找到ai-1存储位置p
- 生成一个新结点*s
- 将新结点*s的数据域置为x
- 新结点*s的指针域指向结点ai
- 令结点*p的指针域指向新结点 *s

插入操作语句描述如下：

```c++
s->next = p->next;
p->next = s;
```

```c++
//在L中第i个元素之前插入数据元素e 
int ListInsert(LinkList L,int i,ElemType e)
{     LNode * p=L; int j=0; 
      while(p!=NULL && j<i−1){p=p->next;++j;}//寻找第i−1个结点 
      if( p==NULL || j>i-1)  
            return -1;	//不存在第i-1个结点，或者i值不合法  
      else
      {    LinkList s=new LNode;		//生成新结点s 
           s->data=e;      		           //将结点s的数据域置为e 
           s->next=p->next;	   	          //将结点s插入L中 
           p->next=s; 
           return 0; 
      }
} 
```

### 删除数据元素

先在单链表L中找到第i-1个结点*p，若存在这样的结点，且也存在后继结点，则删除该后继结点。 

算法步骤：

- 找到ai-1存储位置p
- 临时保存结点ai的地址在q中，以备释放
- 令p->next指向ai的直接后继结点
- 将ai的值保留在e中
- 释放ai的空间

```c++
 int ListDelete(LinkList L,int i,ElemType &e)
{    int j=0; 
     LinkList  p=L;  
     while(p->next && j<i-1)//寻找第i个结点，并令p指向其前驱 
     {         p=p->next;         j++;         } 
     if(!(p->next)  || j>i-1)    return -1; //删除位置不合理 
     LinkList  q=p->next;             //临时保存被删结点的地址以备释放 
     p->next=q->next; 	            //改变删除结点前驱结点的指针域 
     e=q->data; 	                        //保存删除结点的数据域 
     delete q; 	                        //释放删除结点的空间 
     return 0; 
} 
```

时间复杂度：

- 查找：O(n)
- 插入：O(1)
- 删除：O(1)

### 单链表的建立（头插法）

算法步骤：

- 从一个空表开始，创建一个头结点
- 依次读取字符数组a中的元素，生成新结点
- 将新结点插入到当前链表的表头上，直到结束为止

```c++
void CreateList(LinkList &L,ElemType a[],int n)
{ 
      L=new LNode; 
      L->next=NULL; //先建立一个带头结点的单链表 
      for(i=n-1;i>=0;i--)
      { 
          LinkList p=new LNode; //生成新结点 
          p->data = a[i];  
          p->next=L->next;
          L->next=p; 	//插入到表头 
     } 
} 
```

### 单链表的建立（尾插法）

算法步骤：

- 从一个空表L开始，将新结点逐个插入到链表的尾部，尾指针r指向链表的尾结点
- 初始时，r同L均指向头结点。每读入一个数据元素则申请一个新结点，将新结点插入到尾结点后，r指向新结点

```c++
void CreateList(LinkList &L,ElemType a[],int n)
{ //正位序输入n个元素的值，建立带表头结点的单链表L 
      L=new LNode; 
      L->next=NULL; 	
      LinkList r=L; 	                    //尾指针r指向头结点 
      for(i=0;i<n;i++)
      { 
            LinkList  p=new LNode;       //生成新结点 
            p->data = a[i];   	      //输入元素值 
            p->next=NULL; 
            r->next=p;                         //插入到表尾 
            r=p; 	                              //r指向新的尾结点 
       } 
}
```

### 链表的优缺点

优点：

- 数据元素的个数可以自由扩充
- 插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高

缺点：

- 存储密度小
- 存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）

## 循环链表

特点：

- 链表中没有空指针域
- 从循环链表中的任何一个结点的位置都可以找到其他所有结点
- p所指结点为尾结点的条件：p->next==L

## 双向链表

优点：

- 从任一结点出发可以快速找到其前驱结点和后继结点
- 从任一结点出发可以访问其他结点

类型定义：

```c++
typedef struct DuLNode       	//双链表结点类型
  {     ElemType data;
         struct DuLNode *prior;    	//指向前驱结点
         struct DuLNode *next;     	//指向后继结点
 }   DuLNode, *DuLinklist;
```

1. 空双向循环链表 L->next=L
2. 双向循环链表 p->next->prior = p->prior->next = p

### 双向链表的插入

```c++
s->next = p->next;
p->next->prior = s;
s->prior = p;
p->next = s;
```

### 双向链表的删除

```c++
p->next->next->prior = p;
p->next = p->next->next;
```



# 线性表的应用

## 顺序表的算法设计

### 无序表删除表中指定元素

题目：已知长度为n的线性表L采用顺序存储结构。设计一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素。

方法：重建法，设删除L中所有值等于x元素后的顺序表为A，显然A包含在L中，为此A重用L的空间。

思路：扫描顺序表L，重建L只包含不等于x的元素

```c++
void delnode(SqList &L， ElemType x)
{    
     int k=0， i;		  //k记录值不等于x的元素个数
     for (i=0;i<L.length;i++)
           if (L.elem[i]!=x)    //若当前元素不为x，将其插入A中
        {     L.elem[k]=L.elem[i];
	     k++;		 //不等于x的元素增1
        }
      L.length=k;		 //顺序表A的长度等于k
}
```



## 单链表的算法设计

### 以头插法和尾插法两种建表算法为基础的算法设计

题目：假设有一个带头结点的单链表L={a1，a2，…，an}。设计一个算法将所有结点原地逆置，即变为：　L={an，an-1，…，a1}

```c++
void  Reverse(LinkList &L)
{ 
       LNode *p=L->next，*q;
       L->next=NULL;
       while  (p!=NULL)
       {       q=p;
               p=p->next;
               q->next=L->next;
               L->next=q;
        }
}
```

时间复杂度为O(n)，空间复杂度为O(1)。

### 以查找为基础的算法设计

- 按照条件进行结点查找
- 进行插入和删除操作

## 线性表的合并

题目：已知线性表A 和B中的数据元素按值非递减有序排列，现要求将A和B归并为一个新的线性表C，且C中的数据元素仍按值非递减有序排列。

A=(1 ,3, 8)

B=(2, 3, 6, 8, 10, 11)

C=(1, 2, 3 ,3, 6, 8, 8, 10, 11) 

思路：

- 创建一个空表C
- 依次从 A 或 B 中“摘取”元素值较小的结点插入到C 表的最后，直至其中一个表变空为止
- 继续将 A 或 B 其中一个表的剩余结点插入在 C 表的最后

```c++
void MergeList_Sq(SqList A,SqList B,SqList &C)
{    int pa=0,pb=0,pc=0; //指针pa、pb和pc的初值分别指向三个表的第一个元素 
     while( pa<A.length && pb< B.length )    //两个表都非空 
     {      if( A.data[pa]<A.data[pb]) //依次“摘取”两表中值较小的结点 
                   C.data[pc++] = A.data[pa++];      
            else
                   C.data[pc++] = B.data[pb++];
     }
     while( pa<A.length ) C.data[pc++] = A.data[pa++]; //B表已到达表尾
     while( pb<B.length ) C.data[pc++] = B.data[pb++]; //A表已到达表尾 
}
```

T(n)=O( ListLength (A) + ListLength (B))

S(n)= O(m+n)

## 一元多项式相加

思路：

1. 创建一个新链表hc
2. 分别从头遍历比较ha和hb的每一项
   - 指数相同，对应系数相加，若其和不为零，则在hc中增加一个新项
   - 指数不相同，则将指数较小的项复制到hc中
3. 一个多项式已遍历完毕时，将另一个剩余项依次复制到hc中即可

算法步骤

1. 引入指针变量pa,pb,pc
2. 当pa或pb的值不为空时，重复以下过程
   - 若pa->expn=pb->expn则系数相加，并插入在pc所指结点后面，pa、pb和pc后移；若系数之和x=0，则只是把pa、pb往后移动
   - 若pa->expn>pb->expn则在pc所指结点后面插人一个与pb所指结点相同的新结点， pb和pc往后移动。反之亦然。
3. 若pa(或pb)不为空，则将pa(或pb)之后的结点复制到pc所指结点的后面

重复操作：在表尾插入新结点

​	如：在p指针指向的结点之后插入一个系数为c，指数为e的新结点。

​		思路：

​			1. 分配新结点，并令p->next指向它

​			2. p指向新结点

​			3.将新结点的系数部分和指数部分分别赋值

```c++
void attach(float c, int e, PNode* &p)
{
	p->next = (PNode*)malloc(sizeof(PNode))；
            p=p->next；
	p->coef=c；p->expn=e；    
}
```

​	

```c++
void addpolyn(PNode*ha，PNode*hb, PNode *&hc)
{   PNode *pa，*pb，*pc；
    int x；    hc = (PNode*)malloc(sizeof(PNode))；
    pa=ha->next；  	 pb=hb->next；    pc=hc；
    while(pa&&pb)
         if(pa->expn==pb->expn)//指数相同
         { 	  x=pa->coef+pb->coef;
   	  if(x)   attach(x,pa->expn,pc)；
      	  pa=pa->next；   pb=pb->next；
         }
         else if(pa->expn>pb->expn)
         {	attach(pb->coef，pb->expn，pc)；   	pb=pb->next；   }
         else{      attach(pa->coef，pa->expn,pc); pa=pa->next；  }
    while(pa)//pb链处理完，pa链还有结点没有处理
    {    attach(pa->coef，pa->expn,pc)；    pa=pa->next；    }
    while(pb) )//pa链处理完，pb链还有结点没有处理
    {    attach(pb->coef,pb->expn,pc)；      pb=pb->next；   }
    pc->next=NULL；  
}
```

### 一元多项式链表创建

算法步骤：

1. 创建一个只有头结点的空链表
2. 根据多项式的项的个数n，循环n次执行以下操作：
   - n生成一个新结点*s；
   - n输入多项式当前项的系数和指数赋给新结点*s的数据域；
   - n设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点；
   - n指针q初始化，指向首元结点；
   - n循链向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q；
   - n将输入项结点*s插入到结点*q之前。

```c++
void CreatePolyn(Polynomial &hc , int n)
{//输入m项的系数和指数(无序)，建立表示多项式的有序链表hc
   hc=(PNode*)malloc(sizeof(PNode))；
   hc->next=NULL;		//先建立一个带头结点的单链表 
   for(i=1;i<=n;++i)		//依次输入n个非零项
   {      s =(PNode*)malloc(sizeof(PNode)) 		//生成新结点 
          cin>>s->coef>>s->expn;	//输入系数和指数 
          pre=hc;			//pre用于保存q的前驱，初值为头结点 
          q=hc->next;			//q初始化，指向首元结点
          while(q&&q->expn<s->expn)//查找s应该插入的位置
          {            pre=q;             q=q->next;            }			
          s->next=q;	//将输入项s插入到q和其前驱结点pre之间 
          pre->next=s; 
   }	
} 
```

# 约瑟夫环问题

问题描述：

据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。

想法--数据模型：

设 n(n>0)个人围成一个环，n 个人的编号分别为1，2，…，n，从第 1 个人开始报数，报到 m 时停止报数，报 m 的人出环，再从他的下一个人起重新报数，报到 m 时停止报数，报m的人出环，……，如此下去，直到所有人全部出环为止。对于任意给定 n 和 m，求 n 个人出环的次序。

完整代码示例[](http://t.csdnimg.cn/uX3hM)