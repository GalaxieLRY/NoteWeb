---
title: 第3章 栈和队列
date: 2025-08-15
---

## 栈

### 栈的定义

#### 基本概念

栈是一种运算受限的线性表，只能在线性表的同一端进行插入和删除操作

栈顶(top)：允许进行插入、删除操作的一端

栈底(bottom)：表的另一端

空栈：栈中没有数据元素

压栈/入栈：栈的插入操作

弹栈/出栈：栈的删除操作

特点：后进先出（LIFO）

**定义：**只能在表的一端（栈顶）进行插入和删除运算的线性表

**逻辑结构：**与线性表相同，仍为一对一关系

**存储结构：**用顺序栈或链栈存储均可，但以顺序栈更常见

**运算规则：**只能在栈顶运算，且访问节点时依照后进先出（LIFO）或先进后出（FILO）的原则

**基本运算：**入栈，出栈，读栈顶元素值，建栈，判断栈满、栈空等

#### 栈的抽象数据类型定义

```cpp
ADT stack
{
  数据对象：
       D={ a1，a2，…… ，ai，…… ，an }
  数据关系：
       R＝{< ai-1 , ai >｜ai-1 , ai εD，i=1,2,…n}
             a1为栈底，an为栈顶 
  基本操作：
       InitStack (&s)：创建空栈 
       DestroyStack（&s）:销毁栈
       StackEmpty(s)：若栈S为空，则返回1，否则返回0    
       Push(s,x)：在栈插入元素X（入栈），若成功返回1，否则返回0
       Pop(s)：从栈项删除元素X（出栈），若成功返回1，否则返回         
       StackLength(s):求栈长。
       StackFull(s)：栈S若满，则返回1，否则返回0
       GetTop(s)：返回栈顶元素X ，若成功返回1，否则返回0
}ADT stack
```



### 栈的顺序表示和实现

#### 顺序栈的结构定义

```cpp
typedef struct
{
    SElemType *elem;//栈数据表
    int top;//栈顶指针
}SqStack;
```

#### 初始化（置栈空）操作

```cpp
bool InitStack( SqStack &S )
{
         S.elem =new SElemType[MAXSIZE]；
         if( !S.elem ) 	return false;
         S.top = -1;//栈顶位置在-1处
         return true;
}
```

#### 判断顺序栈是否为空

```c++
bool StackEmpty( SqStack S )
{     if(S.top == -1) //判断栈顶位置
             return true;
      else 
            return false;
}
```

#### 求栈中元素个数

```cpp
int StackLength( SqStack S )
{
	return S.top +1;//返回栈顶位置加一
}
```

#### 清空栈

```cpp
void  ClearStack( SqStack &S )
{
	S.top = -1;//使栈顶位置为-1
}
```

#### 销毁顺序栈

```cpp
void DestroyStack( SqStack &S )
{
	 if (S.elem)    
        delete[] S.elem; //释放存储空间		
}
```

#### 进栈push

思路：

1.判断是否栈满，若满则出错

2.栈顶指针加一

3.元素e压入栈顶

```cpp
bool Push(SqStack &S,ElemType e)
{
   if (S.top==MAXSIZE-1)  //栈满，即栈上溢
       return false;
   S.top++;            //栈顶指针增1
   S.elem[S.top]=e;  //元素e放在栈顶处
   return true;
}
```

#### 出栈pop

思路：

1.判断是否栈空，栈空则出错

2.获取栈顶元素e

3.栈顶指针减一

```cpp
bool Pop(SqStack &S,ElemType &e)
{
   if (S.top==-1)    //栈为空，即栈下溢出
        return false;
   e=S.elem[ S.top ];   //取栈顶指针元素
   S.top--;		//栈顶指针减1
   return true;
}
```

#### 取栈顶元素

思路：

1.判断是否空栈，若空则返回false

2.否则通过栈顶指针获取栈顶元素

```cpp
bool GetTop( SqStack S, SElemType &e)  
{
	if( S.top == -1)	
    	return false; 	// 栈空
	e = S.elem[S.top];
	return true;
}
```

#### 共享栈

![共享栈](.\图片\共享栈.png)

共享栈结构类型定义：

```cpp
typedef struct
{      ElemType elem[M];	//存放共享栈中元素
       int top1，top2;		//两个栈的栈顶指针
} DStack;
```

操作：

```cpp
初始化：top1=-1; top2=M;
判断栈1空：top1==-1;
判断栈2空：top2==M;
判断栈满：top+1==top2;
元素进栈1：top1++; elem[top1]=e;
元素进栈2：top2--; elem[top2]=e;
栈1出栈：e=elem[top1];top--;
栈2出栈：e=elem[top2];top2++;
```

### 栈的链式表示和实现

采用带头节点的单链表实现

链栈四要素：

>栈空条件：s->next=NULL;
>栈满条件：不考虑；
>进栈操作：将包含e的节点插入到头节点之后；
>退栈操作：取出头节点，并删除之后节点的元素；

#### 链栈类型定义

```cpp
typedef struct StackNode
{     ElemType data;	//数据域
      struct StackNode* next;//指针域
}  StackNode,*LinkStack;

LinkStack S;
```

#### 初始化栈

思路：

建立一个空栈S，实际上史创建链栈的头节点，并将其next域置为NULL。

```cpp
void InitStack(LinkStack &S)
{     S=(StackNode *)malloc(sizeof(StackNode));
      //S = new StackNode;
       S.next=NULL;
}
```

#### 销毁栈

逐一释放存储空间

```cpp
void DestroyStack(LinkStack &S)
{
    StackNode *p=S，*q=S->next;
 	while (q!=NULL)
 	{	
        free(p);  //delete(p);
		p=q;
		q=p->next;
    }
    free(p);	// delete(p);  此时p指向尾结点，释放其空间
}
```

#### 判断栈是否为空

```cpp
bool StackEmpty(LinkStack  S)
{
       return(S->next==NULL);
}
```

#### 进栈

思路：

将新数据节点插入到头节点之后

```cpp
void Push(LinkStack  S，ElemType e)
{      
    LinkStNode *p;
    p=(StackNode *)malloc(sizeof(StackNode));
    p->data=e;		//新建元素e对应的结点*p
    p->next=S->next;	//插入*p结点作为开始结点
    S->next=p;
}
```

#### 出栈

```cpp
bool Pop(LinkStack S，ElemType &e)
{     StackNode *p;
      if (S->next==NULL)		//栈空的情况
	return false;
      p=S->next;			//p指向开始结点
      e=p->data;
      S->next=p->next;		//删除*p结点
      free(p);			//释放*p结点
      return true;
}
```

#### 取栈顶元素

```cpp
bool GetTop(LinkStack S，ElemType &e)
{      if (S->next==NULL)	//栈空的情况
	return false;
       e=S->next->data;
       return true;
}
```

### 栈的应用

#### 数制转换问题

设计一个算法将一个十进制正整数转换为相应的二进制数

> 将十进制正整数转换成二进制数通常采用除2取余数法。
>
> 在转换过程中，二进制数是从低位到高位的次序得到的，这和通常的从高位到低位输出二进制的次序相反。
>
> 为此设计一个栈，用于暂时存放每次得到的余数，当转换过程结束时，退栈所有元素便得到从高位到低位的二进制数

思路：

1.初始化一个空栈S

2.当十进制数N>0时，循环执行以下操作：

- 把N与r求余得到的r进制数压入栈S
- N更新为N与r的商

3.当栈S非空时，循环执行以下操作：

- 弹出栈顶元素e
- 输出e

```cpp
void conversion(int  N , int  r) 
{   //将十进制整数N转换为r(2或8)进制数
      SqStack  S ;    
      int k, e ;
      InitStack(S);//初始化为空栈S
      while  (N>0)  /*  求出所有的余数，进栈  */
      {      k=N%r ; 
             Push(S , k) ; //进栈
             N=N/r ;   
      } 
      while  (!StackEmpty(S))     // 栈不空时出栈，输出 
      {      Pop(S, e) ;          //出栈
             cout<<e ; 
      }
}
```

#### 对称串（回文）问题

> 设计一个算法利用顺序栈判断一个字符串是否是对称串
>
> 所谓对称串（回文）是指从左向右读和从右向左读的序列相同

思路：

字符串str的所有元素依次进栈，产生的出栈序列如果正好与str的顺序相反，则为对称串

```cpp
bool symmetry(ElemType str[])
{    int i;  ElemType e; 
     SqStack S;
     InitStack(S);			//初始化栈
 
	/*str的所有元素依次进栈*/
     for (i=0;str[i]!='\0';i++)	//将串所有元素进栈
	Push(S，str[i]);		//元素进栈
 
	/*判断字符串的正反序是否相同*/
     for (i=0;str[i]!='\0';i++)
     {    Pop(S，e);			//退栈元素e
           if (str[i]!=e)	 	//若e与当前串元素不同则不是对称串
           {     DestroyStack(S);	//销毁栈
	   			return false;
           }
     }

     DestroyStack(S);	 	//销毁栈
     return true;
}
```

#### 括号匹配问题

> 编写一个算法判断输入的表达式中括号是否配对（假设只含有左、右圆括号）

![括号不匹配](.\图片\括号不匹配.png)

![括号匹配](.\图片\括号匹配.png)

思路：

1. 初始化一个空栈st
2. 设置一标志性变量match，用来标记匹配结果以控制循环及返回结果，true表示正确匹配，false表示错误匹配，match初值为true
3. 扫描表达式，依次读入字符ch，如果表达式没有扫描完毕或match为true，则循环执行以下操作：
   - 若ch是"["或"("，则将其压入栈；
   - 若ch是")"，则若栈非空且栈顶元素是"("，则正确匹配，否则错误匹配，match置为false;
   - 若ch是"]"，则若栈非空且栈顶元素是"["，则正确匹配，否则错误匹配，match置为false。
4. 退出循环后，如果栈空且match值为true，则匹配成功，返回true，否则返回false.

```cpp
bool Match(char exp[]，int n)
{     int i=0; char e;  

      bool match=true; 

      LinkStack S;

      InitStack(S);		      	//初始化栈
      while (i<n && match)	//扫描exp中所有字符
      { 
            if (exp[i]=='(')//遇到任何左括号都进栈
	   			Push(S，exp[i]);
          	else if (exp[i]==')') 		//当前字符为右括号，遇到右括号判断是否匹配
          	{      
                if (GetTop(S，e)==true)
	   			{    
                    if (e!='(')	   	//栈顶元素不为'('时表示不匹配
						match=false;
	         		else
						Pop(S，e);    	//将栈顶元素出栈
	   			}
	   			else  
                	match=false;  	//无法取栈顶元素时表示不匹配
          	}
          	i++;			//继续处理其他字符
     }
     if (!StackEmpty(S))	//栈不空时表示不匹配
		match=false;
     DestroyStack(S);	     	//销毁栈
     return match;
}
```

#### 表达式求值问题

**中缀表达式求值**

如：1+2*3

> 运算规则：先乘除，后加减，从左到右计算，先括号内，后括号外
>
> 因此，中缀表达式不仅要依赖运算符优先级，而且还要处理括号

运算符优先级

思路：

设定两栈：OPND---操作数或运算结果   OPTR---运算符

1. 初始化OPTR栈和OPND栈，将表达式起始符“#”压入OPTR栈
2. 扫描表达式，读入第一个字符ch，如果表达式没有扫描完毕至“#”或OPTR的栈顶元素不为“#”时，则循环执行以下操作：

- 若ch不是运算符，则压入OPND栈，读入下一字符ch；

- 若ch是运算符，则根据OPTR的栈顶元素和ch的优先级比较结果，做不同的处理：
  - 若是小于，则ch压入OPTR栈，读入下一字符ch；
  - 若是大于，则弹出OPTR栈顶的运算符，从OPND栈弹出两个数，进行相应运算，结果压入OPND栈，不扫描下一个字符；
  - 若是等于，若OPTR的栈顶元素是“（”且ch是“）”，这时弹出OPTR栈顶的“）”，相当于括号匹配成功，但不从操作数栈弹出两个数，然后读入下一字符ch.

	3. OPND栈顶元素即为表达式求值结果，返回此元素。

```cpp
OperandType  EvaluateExpression( ) {
  	InitStack (OPTR);  
    Push (OPTR，'#');
  	InitStack (OPND);  
    ch = getchar( );
  while (ch!= '#' || GetTop(OPTR)! = '#') {
    if (! In(ch)){
        Push(OPND,ch); 
        ch = getchar(); 
    }  // ch不是运算符则为操作数，进栈
    else
        switch (Precede(GetTop(OPTR),ch)) { //比较优先权
        	case '<' :    //当前字符ch压入OPTR栈，读入下一字符ch
              	Push(OPTR, ch);  
                ch = getchar();  
                break;
        	case '>' :    //弹出OPTR栈顶的运算符运算，并将运算结果入栈
              	Pop(OPTR, theta);
              	Pop(OPND, b);  
                Pop(OPND, a);
              	Push(OPND, Operate(a, theta, b)); 
                break;
        	case '=' :    //脱括号并接收下一字符
              	Pop(OPTR,x);    
                ch = getchar();   
                break;
        } // switch
  } // while
  return GetTop(OPND);} // EvaluateExpression

```

完整代码示例[](http://t.csdnimg.cn/L0pbu)

**后缀表达式求值问题**

如：

> 中缀：(5*(12-3)+4)/2
>
> 后缀：5 12 3 - * 4 + 2 /

中缀表达式转换为前缀或后缀表达式的一种手工做法：

> a/b+((c*d)-(e*f))/g
>
> 第—步：按照运算符的优先级对所有的运算单位加括号。
>
> ​	 式子变为： ((a/b)+(((c*d)-(e*f))/g))
>
> 第二步：转换为前缀或后缀表达式。
>
> ​	•前缀：先把运算符号移动到对应的括号前面。变为：      +(/(ab)/(-(*(cd)*(ef))g))，再把括号去掉即可：+/ab/-*cd*efg。
>
> ​	•后缀：先把运算符号移动到对应的括号后面。变为：((ab)/(((cd)*(ef)*)-g)/)+，再把括号去掉即可：ab/cd*ef*-g/+。

后缀表达式的优点：

1. 已考虑了运算符的优先级
2. 没有括号
3. 只有操作数和运算符，而且越放在前面的运算符越优先执行

后缀表达式的求值过程：

1. 将中缀算术表达式转换成后缀表达式

   [](http://t.csdnimg.cn/5MQOo)

2. 对该后缀表达式求值

   [](http://t.csdnimg.cn/ai4ny)

**后缀表达式求值**

思路：

- 数字字符：转换为数值并进栈
- 运算符：退栈两个操作数，计算，将结果进栈

>while (从postexp读取字符ch，ch!='\0')
>
>{    ch为'+'：从OPND栈中出栈两个数值a和b，计算c=b+a;将c进栈;
>
>​    ch为'-'：从OPND栈中出栈两个数值a和b，计算c=b-a;将c进栈;
>
>​    ch为'*'：从OPND栈中出栈两个数值a和b，计算c=b*a;将c进栈;
>
>​    ch为'/'：从OPND栈中出栈两个数值a和b，若a不零，计算c=b/a;将c进栈;
>
>​    ch为数字字符：将连续的数字串转换成数值d，将d进栈;
>
>}
>
>返回OPND栈的栈顶操作数即后缀表达式的值;

```cpp
double compvalue(char *postexp)//计算后缀表达式postexp的值。
{      double d， a， b， c， e;
        SqStack OPND;			//定义操作数栈
        InitStack(OPND);			//初始化操作数栈
        while (*postexp!='\0')	         //postexp字符串未扫描完时循环
        {	 
            switch (*postexp){
	 			case '+':			//判定为'+'号
                  Pop(OPND，a);		//出栈元素a
                  Pop(OPND，b);		//出栈元素b
                  c=b+a;			//计算c
                  Push(OPND，c);	//将计算结果c进栈
                  break;
				case '-':				//判定为'-'号
                    Pop(OPND，a);		//出栈元素a
                    Pop(OPND，b);		//出栈元素b
                    c=b-a;			//计算c
                    Push(OPND，c);		//将计算结果c进栈
                    break;
				case '*':				//判定为'*'号
                   Pop(OPND，a);		//出栈元素a
                   Pop(OPND，b);		//出栈元素b
                   c=b*a;			//计算c
                   Push(OPND，c);		//将计算结果c进栈
                   break;
        		case '/':				//判定为'/'号
                   Pop(OPND，a);		//出栈元素a
                   Pop(OPND，b);		//出栈元素b
                   if (a!=0)
                   {	
                       	c=b/a;			//计算c
                        Push1(OPND，c);		//将计算结果c进栈
                        break;
                   }
                   else
                   {	
                       	printf("\n\t除零错误!\n");
                		exit(0);			//异常退出
                   }
                   break;
                default:		//处理数字字符
                      d=0;		//转换成对应的数值存放到d中
                      while (*postexp>='0' && *postexp<='9')
                      {	d=10*d+*postexp-'0';
                    postexp++;
                      }
                      Push(OPND，d);	//将数值d进栈
                      break;
                }
			postexp++;		//继续处理其他字符
        }
        GetTop(OPND，e);	//取栈顶元素e
        DestroyStack(OPND);	//销毁栈
        return e;			//返回e
}

```

**将中缀表达式转换为后缀表达式**

思路：

- 数字字符直接放在postexp中
- 运算符通过一个栈来处理优先级

![中转后1](.\图片\中转后1.png)

![](.\图片\中转后2.png)

>while (从exp读取字符ch，ch!='\0')
>
>{    ch为数字：将后续的所有数字均依次存放到postexp中，并以字符'#'标志数值串结束;
>
>​    ch为左括号'('：将此括号进栈到Optr中;
>
>​    ch为右括号')'：将Optr中出栈时遇到的第一个左括号'('以前的运算符依次出栈并存放到postexp中，然后将左括号'('出栈;
>
>​    ch为其他运算符：
>
> if （栈空或者栈顶运算符为'('）  直接将ch进栈;
>
> else if (ch的优先级高于栈顶运算符的优先级)
>
>​    直接将ch进栈;
>
> else
>
>​     依次出栈并存入到postexp中，直到栈顶运算符优先级小于ch的优先级，
>
>​    然后将ch进栈;
>
>}
>
>若exp扫描完毕，则将Optr中所有运算符依次出栈并存放到postexp中。

```cpp
void trans(char *exp，char postexp[])//将算术表达式exp转换成后缀表达式postexp
{     char e;  
       SqStack  Optr;		//定义运算符栈指针
       InitStack(Optr);		//初始化运算符栈
       int i=0;			//i作为postexp的下标
       while (*exp!='\0')		//exp表达式未扫描完时循环
       { 	switch(*exp)
	{   case '(':		//判定为左括号
	         Push(Optr，'(');	//左括号进栈
	         exp++;		//继续扫描其他字符
	         break;
                  case ')':		    //判定为右括号
	        Pop(Optr，e);	    //出栈元素e
	        while (e!='(')	    //不为'('时循环
	        {	  postexp[i++]=e;	    //将e存放到postexp中
		  Pop(Optr，e);	    //继续出栈元素e	         }
	         exp++;		     //继续扫描其他字符
	         break;
              case '+':				//判定为加或减号
	  case '-':
	       while (!StackEmpty(Optr))	//栈不空循环
	       {        GetTop(Optr，e);		//取栈顶元素e
	                 if (e!='(')			//e不是'('
		     {      postexp[i++]=e;	//将e存放到postexp中
			Pop(Optr，e);		//出栈元素e
		      }
		      else			//e是'(时退出循环
			break;
	       }
	       Push(Optr，*exp);		//将'+'或'-'进栈
	       exp++;			//继续扫描其他字符
	       break;
              case '+':				//判定为加或减号
	  case '-':
	       while (!StackEmpty(Optr))	//栈不空循环
	       {        GetTop(Optr，e);		//取栈顶元素e
	                 if (e!='(')			//e不是'('
		     {      postexp[i++]=e;	//将e存放到postexp中
			Pop(Optr，e);		//出栈元素e
		      }
		      else			//e是'(时退出循环
			break;
	       }
	       Push(Optr，*exp);		//将'+'或'-'进栈
	       exp++;			//继续扫描其他字符
	       break;
            case '*':				//判定为'*'或'/'号
	case '/':
	    while (!StackEmpty(Optr))	//栈不空循环
	    {      GetTop(Optr，e);		//取栈顶元素e
	            if (e=='*' || e=='/')
		{       postexp[i++]=e;	//将e存放到postexp中
		        Pop(Optr，e);	//出栈元素e
		}
		else			//e为非'*'或'/'运算符时退出循环
		      break;
	    }
	    Push(Optr，*exp);		//将'*'或'/'进栈
	    exp++;			//继续扫描其他字符
	    break;
	default:			//处理数字字符
	    while (*exp>='0' && *exp<='9')      //判定为数字字符
	    {       postexp[i++]=*exp;
		exp++;
	     }
	     postexp[i++]='#';	//用#标识一个数值串结束
	}
        }
        while (!StackEmpty(Optr))//此时exp扫描完毕，栈不空时循环
        {     Pop(Optr，e);		//出栈元素e
	  postexp[i++]=e;		//将e存放到postexp中
        }
        postexp[i]='\0';		//给postexp表达式添加结束标识
        DestroyStack(Optr);	//销毁栈
}
```

过程：

- 设计求解程序

```cpp
void main()
{      char exp[]="(56-20)/(4+2)";	 //可将exp改为键盘输入
        char postexp[MAXSIZE];
        trans(exp，postexp);
        printf("中缀表达式:%s\n"，exp);
        printf("后缀表达式:%s\n"，postexp);
        printf("表达式的值:%g\n"，compvalue(postexp));
}
```

- 运行结果

  >中缀表达式:(56-20)/(4+2)
  >
  >后缀表达式:56#20#-4#2#+/
  >
  >表达式的值:6

#### 栈与递归的实现

递归算法的递归模型
$$
Fact(n)=\begin{cases}
 1,\,\,n=0,1\\
 n*Fact(n-1),\,\,n>1\\
 \end{cases}
$$
如：

```cpp
long Fact(long n)
{         
    if(n==0||n==1)
        f=1;      //递归出口
     else
          f =n*Fact(n-1);    //递归体        
     return(f);   
}
```

当多个函数构成嵌套调用时，遵循后调用先返回

调用前，系统完成：

> (1)将实参,返回地址等传递给被调用函数
>
> (2)为被调用函数的局部变量分配存储区
>
> (3)将控制转移到被调用函数的入口

调用后，系统完成：

> (1)保存被调用函数的计算结果
>
> (2)释放被调用函数的数据区
>
> (3)依照被调用函数保存的返回地址将控制转移到调用函数

![](.\图片\递归图示.png)

递归优缺点：

优点：结构清晰，程序易读

缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。

什么时候使用递归？

- 递归定义的数学函数

  如：阶乘函数
  $$
  Fact(n)=\begin{cases}
   1,\,\,n=0,1\\
   n*Fact(n-1),\,\,n>1\\
   \end{cases}
  $$
  2阶Fibonaci数列:
  $$
  Fib(n)=\begin{cases}
   1,\,\,n=1,2\\
   Fib(n-1)+Fib(n-2),\,\,n>2\\
   \end{cases}
  $$
  
- 具有递归特性的数据结构

  ```cpp
  typedef  struct LNode 
  {      ElemType data;
         struct LNode *next;	  
  }  Lnode,*LinkList;      
  ```

  树的遍历、图的搜索都采用递归

  如：设计一个算法求一个不带头结点的单链表L的所有data域之和

  ```cpp
  int Sum(LinkList L)
  {   if (L==NULL)
           return 0;
      else 
           return( L->data+Sum(L->next));
  } 
  ```

- 可递归求解的问题

  Hanoi塔问题   

**汉诺塔问题**

思路：

>  n = 1，则直接从 A 移到 C。
>
>  n > 1，则
>
>(1)用 C 柱做过渡，将 A 的(n-1)个移到 B
>
>(2)将 A 最后一个直接移到 C 
>
>(3)用 A 做过渡，将 B 的 (n-1) 个移到 C

设Hanoi(n，A，B，C)表示 将n个盘片从A通过B移动到C上。

```cpp
int c=0;
void move(int n,char a,char c)
{   cout<<++c<<","<<n<<","<<a<<","<<c<<endl;   }

void Hanoi(int n,char A,char B,char C)
{   if(n==1)  move(1,A,C);
    else
    {   Hanoi(n-1,A,C,B); 
        move(n,A,C);
        Hanoi(n-1,B,A,C);  
    }
}
void main()
{     Hanoi(3,'a','b','c');      }
```

算法效率分析

时间效率：与递归书的节点数成正比 O(2^n)

空间效率：与递归树的深度成正比 O(n)

![](.\图片\递归的算法效率分析.png)

## 队列

### 队列的定义

队列也是一种操作受限的线性表，规定：

- 队尾(rear)--允许插入的一端，表尾
- 队头(front)--允许删除的一端，表头

队列Q=（a1, a2,...an, an+1）

队列特点：先进先出（FIFO）或后进后出（LILO）

队列的抽象数据类型定义：

>ADT Queue {
>
>​	数据对象:D={a_i |a_i∈ElemSet,i=1,2,⋯,n," n"≥0}
>
>​	数据关系:
>
>​	基本操作：
>
>>(1) InitQueue (&Q)     //构造空队列
>>
>>   (2) DestroyQueue (&Q)  //销毁队列
>>
>>   (3) QueueEmpty(S)     //判空. 空--TRUE
>>
>>   (4) EnQueue (&Q,e)    //入队列
>>
>>   (5) DeQueue (&Q,&e)   //出队列
>
>}ADT Queue

### 队列的顺序表示和实现

顺序队列类型SqQueue定义如下：

```cpp
typedef struct 
{     QElemType *elem； 
      int front,rear；      //队头和队尾指针
}SqQueue;
```

注意：

- front指向队头元素
- rear指向队尾元素下一个位置

顺序队四要素（初始时，front=rear=0）:

- 队空条件：front==rear
- 队满条件：rear==MAXSIZE
- 元素e进队：elem[rear]=e; rear++;
- 元素e出队：e=elem[front]; front++;

#### 环形队列

定义：把数组的前端和后端连接起来，形成一个环形的顺序表，即把存储队列元素的表从逻辑上看成一个环，称为环形队列或循环队列。

四要素：

- 队空条件：front==rear
-  队满条件： (rear+1)%MAXSIZE==front（牺牲一个元素空间来换取队空和队满条件的区分）
- 进队操作：将e放在rear处; rear=(rear+1)%MAXSIZE  
- 出队操作：取出front处元素e; front=(front+1)%MAXSIZE; 

1.已知front、rear，求队中元素个数count：

​		count=(rear-front+MAXSIZE)%MAXSIZE

2.已知front、count，求rear：

​		rear=(front+count)%MAXSIZE

3.已知rear、count，求front：

​		front=(rear-count+MAXSIZE)%MAXSIZE

**队列初始化（循环队列置空）操作**

```cpp
bool InitQueue(SqQueue &Q)
{    Q.elem=(QElemType *)malloc(MAXSIZE*sizeof(QElemType));
     //Q.elem = new QElemType[MAXSIZE];
     if(!Q.elem)
         return false;
     Q.front=Q.rear=0;
     return true;
}
```

**入队操作**

```cpp
bool EnQueue(SqQueue &Q,ElemType e)
{  if ((Q.rear+1)%MAXSIZE==Q.front)  //队满上溢出
	return false;
   Q.elem[Q.rear]=e;
   Q.rear=(Q.rear+1)%MAXSIZE;
   return true;
}
```

**出队操作**

```cpp
bool DeQueue(SqQueue &Q,ElemType &e )
{ 
   if (Q.rear==Q.front)  //队空下溢出
	return false;
   e=Q.elem[Q.front];
   Q.front=(Q.front+1)%MAXSIZE;
   
   return true;
}
```

#### 注意：

- 显然环形队列比非环形队列更有效利用内存空间，即环形队列会重复使用已经出队元素的空间。不会出现假溢出。
- 但如果算法中需要使用所有进队的元素来进一步求解，此时可以使用非环形队列。

### 队列的链式表示和实现

存储结构定义：

```cpp
typedef struct QNode
{  ElemType         data;  	
   struct QNode  *next;
} QNode;  //数据结点类型
typedef struct
{  QNode *front; 
   QNode *rear;  
} LinkQueue; //链队结点类型
```

![](.\图片\链队示意图.png)

链队操作示意图

![](.\图片\链队操作示意图.png)

链队四要素：

- 队空条件： front==rear
- 队满条件： 不考虑
- 进队e操作：将包含e的结点插入到单链表表尾
- 出队操作： 删除单链表头结点后的第一个数据结点

**初始化队列**

构造一个空队列，即只创建一个链队头结点，其front和rear域均置为NULL，不创建数据元素结点。

```cpp
void InitQueue(LinkQueue &Q)
{
       Q.front = (QNode *)malloc(sizeof(QNode));
       Q.rear = Q.front;
       Q.front->next = NULL;
}
```

**销毁队列**

释放队列占用的存储空间，包括链队头结点和所有数据结点的存储空间。

```cpp
void DestroyQueue(LinkQueue &Q)
{      
       while(Q.front!=NULL)		
        {      Q.rear=Q.front->next;
	   free(Q.front);             //释放数据结点占用空间
	   Q.front=Q.rear;
        }

}
```

**判断队列是否为空**

若链队结点的rear域值为NULL，表示队列为空，返回true；否则返回false。

```cpp
bool QueueEmpty(LinkQueue Q)
{
　　return(Q.rear==Q.front);
}
```

**入队**

```cpp
void EnQueue(LinkQueue &Q，ElemType e)
{ 
       QNode *p;
       p=(QNode *)malloc(sizeof(QNode));
       p->data=e;
       p->next=NULL;
       Q.rear->next=p;   //将*p结点链到队尾，并将rear指向它
       Q.rear=p;
}
```

**出队**

```cpp
bool DeQueue(LinkQueue &Q，ElemType &e)
{     QNode *p;
      if (Q.rear==Q.front)   return false;	//队列为空
      p=Q.front->next;	   	//p指向第一个数据结点
      e=p->data;
      Q.front->next=p->next;
      if (Q.rear==p)  		//队列中只有一个结点时
	Q.rear=Q.front;     //删除后，队尾指针也指向头结点
      free(p);
      return true;
}
```

#### 循环单链表存储队列

特点：不带头结点只有一个尾结点指针rear

![](.\图片\循环单链表存储队列.png)

四要素：

- 队空条件：rear=NULL
- 队满条件：不考虑
- 进队e操作：将包含e的结点插入到单链表表尾
- 出队操作：删除单链表首结点

**初始化队列**

```cpp
void InitQueue(QNode *rear)　
{
　　rear=NULL;
}
```

**判断队空**

```cpp
bool QueueEmpty(QNode *rear）
{
      return(rear==NULL);
}
```

**入队**

```cpp
void EnQueue(QNode *rear，ElemType x)
{     QNode *p=(QNode *)malloc(sizeof(QNode));    //创建新结点
      p->data=x;
      if (rear==NULL)		//原链队为空
      {	p->next=p;		//构成循环链表
	rear=p;
      }
      else
      {     p->next=rear->next;	//将*p结点插入到*rear结点之后
            rear->next=p;
            rear=p;			 //让rear指向这个新插入的结点
     }
}
```

**出队**

```cpp
bool DeQueue(QNode *rear，ElemType &x)	
{     QNode *q;
      if (rear==NULL)   return false;	   //队空
      else if (rear->next==rear)	   //原队中只有一个结点
      {     x=rear->data;
            free(rear);
            rear=NULL;
      }
      else			     	   //原队中有两个或以上的结点
      {	q=rear->next;
	x=q->data;
	rear->next=q->next;
	free(q);
      }
     return true;
}
```

### 双端队列

双端队列是限定插入和删除操作在表的两端进行的线性表。

![](.\图片\双端队列.png)

在实际使用中，还可以有输出受限的双端队列(即一个端点允许插入和删除，另一个端点只允许插入的双端队列)和输入受限的双端队列(即一个端点允许插入和删除，另一个端点只允许删除的双端队列)。而如果限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻的栈了。

双端队列与队列一样，元素的逻辑关系也是线性关系，但普通队列只能在一端进队，另外一端出队，而双端队列可以在两端进行进队和出队操作，具有队列和栈的特性，因此使用更加灵活。

P154